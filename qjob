#!/bin/bash

# Purpose: The script is to generate PBS job file for WIEN2k with bash shell. After run the job will
#          +create .machines file for mpi-parallel execution of all lapw[012]*_mpi programs
# Author : Maxim Rakitin
# Email  : rms85@physics.susu.ac.ru
# Date   : 2010-10-28 (Thur)
# Version: 2.0 (initial version is qjob_mpi)

############################ Variables #################################
source $HOME/bin/skif-bin/.config/$(hostname | cut -d. -f1).nodes
script_dir=$(basename $0)
init_dir=$(echo $PWD | sed 's|/panfs/panasas||g')
calc_dir=$(basename $init_dir)
outfile="$init_dir/job/$calc_dir.mpi"
struct_file=${calc_dir}.struct
wien_version=$(printf "%1.0f\n" "$(cat ${WIENROOT}/VERSION | awk '{print $1}' | cut -d_ -f2)")
# Set iteraitive diagonalization option depending on WIEN2k version
# WIEN2k_08/09: -it0;  WIEN2k_10: -noHinv
if [ "${wien_version}" -ge "8" -a "${wien_version}" -lt "10" ]; then
    it="-it0"
elif [ "${wien_version}" -ge "10" ]; then
    it="-noHinv"
fi

############################ Constants #################################
# Nodes/cores/walltime default values
nodes="1"
ppn="${cores_per_node}"
walltime="500"
# Init default input values
vxc="13"
ecut="-7.0"
rkmax="10.0"
numk="64"

############################ Help part #################################
help ()
{
cat << EOF

This is job file generator for PBS-Torque queue system on SKIF Ural.
I hope this will work on SKIF Aurora and other SUSU's supercomputers.

Requirements: in the calculation directory must be a struct file.

Author  : Maxim Rakitin (rms85@physics.susu.ac.ru)
Date    : 2010-11-02 (Tue)
Version : 2.1

Usage:
------
    - Without options (all default values will be used):
	${script_dir}

    - With cores/nodes/duration (default: $nodes:$ppn:$walltime):
	$(basename $0) -n/-nodes 2:8:700

    - With initialization (default: ${vxc}:${ecut}:${rkmax}:${numk}):
	${script_dir} -i/-init 13:-6.0:7.0:27
      this will generate init_lapw string with
      Vxc=13 (PBE), Ecut=-6.0, RKmax=7.0, and 27 k-points 
      Example: 
	init_lapw -red 0 -vxc 13 -ecut -6.0 -rkmax 7.0 -numk 27 -b -sp -nosgroup >> init.log

    - With usual SCF cycle (runsp, which is default option):
	${script_dir} -s/-scf ( run | runsp )
      Example:
	runsp_lapw -p -I $it -ec 0.0001 -cc 0.001 -i 300

    - With minimization:
	${script_dir} -s/-scf ( m | min | min_lapw )
      Example:
	min -I -noex -j "runsp_lapw -p -I $it -ec 0.0001 -cc 0.001 -fc 1.0 -i 300"

    - With volume optimization:
	${script_dir} -s/-scf ( v | vol | volopt )
      Example:
	$PWD/${calc_dir}.job
      Note: to run a volume optimization you must have this file, which is generated by 'x optimize'

    - Run lapw0 in serial mode:
	${script_dir} -l0/-lapw0 ( s | ser | serial)

    - Run lapw0 in parallel mode (lapw0_mpi):
        ${script_dir} -l0/-lapw0 ( p | para | parallel)

    - Add infinite loop at the end of the job to prevent job stop till walltime ends:
        ${script_dir} -l/-loop

    - Submit the job:
	${script_dir} -q/-qsub

    - Invoke help:
        ${script_dir} -h/-H/-help

All these options can be used together or separately (in this case default values will be used for other parameters).

Output file will be $outfile

EOF

exit 1
}

######################### Arguments part ###############################
unset nodes_opts init_opts scf_opts lapw0_opts
unset loop qsub dos

while [ "$#" -gt "0" ] ; do
  arg=$1
  shift
  case $arg in
     -n | -nodes | --nodes)
	if [ ! -z "${nodes_opts}" ]; then
	    echo -e "
WARNING!!! You specified '-n/-nodes' option twice
           Use '${script_dir} -h' for more information"
	    exit 2
	fi
        nodes_opts="$1"
        shift
        ;;
     -i | -init | --init)
        if [ ! -z "${init_opts}" ]; then
            echo -e "
WARNING!!! You specified '-i/-init' option twice
           Use '${script_dir} -h' for more information"
            exit 3
        fi
        init_opts="$1"
        shift
        ;;
     -s | -scf | --scf)
        if [ ! -z "${scf_opts}" ]; then
            echo -e "
WARNING!!! You specified '-s/-scf' option twice
           Use '${script_dir} -h' for more information"
            exit 4
        fi
        scf_opts="$1"
        shift
        ;;
     -l0 | -lapw0 | --lapw0)
        if [ ! -z "${lapw0_opts}" ]; then
            echo -e "
WARNING!!! You specified '-l0/-lapw0' option twice
           Use '${script_dir} -h' for more information"
            exit 5
        fi
        lapw0_opts="$1"
	shift
	;;
     -l | -loop | --loop)
        if [ ! -z "${loop}" ]; then
            echo -e "
WARNING!!! You specified '-l/-loop' option twice
           Use '${script_dir} -h' for more information"
            exit 6
	fi
	loop=yes
        ;;
     -q | -qsub | --qsub)
        if [ ! -z "${qsub_opts}" ]; then
            echo -e "
WARNING!!! You specified '-q/-qsub' option twice
           Use '${script_dir} -h' for more information"
            exit 7
        fi
	qsub=yes
	;;
     -d | -dos | --dos)
        dos=yes
        ;;
     * )
        help
	;;
  esac
done


############################ Check part ################################
#---> Check '-it' option for different versions of WIEN2k
if [ "${wien_version}" -gt "11" -o "${wien_version}" -lt "8" ]; then
    echo -e "
WARNING!!! Your WIEN2k version (${wien_version}) differs from 8, 9, 10 or 11.
           Please update this script ${script_dir} with correct iterative 
           diagonalization parameter (use runsp -h for more information)."
    help
fi

#---> Check case.struct file
if [ ! -f "$struct_file" ]; then
    echo -e "
WARNING!!! There is no case.struct file in the directory"
    help
fi

#---> Check 'nodes' argument (Format: 1:8:500)
if [ ! -z "${nodes_opts}" ]; then
    nodes=$(   echo "${nodes_opts}" | cut -d: -f 1)
    ppn=$(     echo "${nodes_opts}" | cut -d: -f 2)
    walltime=$(echo "${nodes_opts}" | cut -d: -f 3)
fi

#---> Init string definition
if [ -z "${init_opts}" ]; then
    init_string=""
else
    if [ "${init_opts}" != "d" -a "${init_opts}" != "def" -a "${init_opts}" != "default" ]; then
	vxc=$(  echo "${init_opts}" | cut -d: -f 1)
	ecut=$( echo "${init_opts}" | cut -d: -f 2)
	rkmax=$(echo "${init_opts}" | cut -d: -f 3)
	numk=$( echo "${init_opts}" | cut -d: -f 4)
    fi
    init_string="\
init_lapw -red 0 -vxc $vxc -ecut $ecut -rkmax $rkmax -numk $numk -b -sp -nosgroup >> init.log 2>> init.err
sed 's/^init_lapw/#init_lapw/g' -i job/${calc_dir}.mpi

"
fi

#---> WIEN2k SCF options
run_string='run_lapw -p -I '$it' -ec 0.0001 -cc 0.001 -i 300'
runsp_string='runsp_lapw -p -I '$it' -ec 0.0001 -cc 0.001 -i 300'
min_string='min -I -noex -j "runsp_lapw -p -I '$it' -ec 0.0001 -cc 0.001 -fc 1.0 -i 300"'
volopt_string="$PWD/${calc_dir}.job"

if [ "${scf_opts}" = "m" -o "${scf_opts}" = "min" -o "${scf_opts}" = "min_lapw" ]; then
    scf_string="${min_string}"
elif [ "${scf_opts}" = "v" -o "${scf_opts}" = "vol" -o "${scf_opts}" = "volopt" ]; then
    scf_string="${volopt_string}"
elif [ "${scf_opts}" = "runsp" ]; then
    scf_string="${runsp_string}"
elif [ "${scf_opts}" = "run" ]; then
    scf_string="${run_string}"
fi

if [ ! -z "${scf_string}" ]; then
    scf_string_block="\
${scf_string}

"
fi

#---> Process lapw0 string in .machines file
# Previous WIEN2k versions (08.3 and 09.2) used to not have lapw0_mpi compiled correctly. They use serial version of lapw0
if [ "${lapw0_opts}" = "p" -o "${lapw0_opts}" = "para" -o "${lapw0_opts}" = "parallel" ]; then
    lapw0_string='\
lapw0:$(echo $(echo "${nodes_list}" | head -'${cores_per_node}'))
'
elif [ -z "${lapw0_opts}" -o "${lapw0_opts}" = "s" -o "${lapw0_opts}" = "ser" -o "${lapw0_opts}" = "serial" ]; then 
    lapw0_string=""
else
    help
fi

#---> Process loop option
if [ "${loop}" = "yes" ]; then
    loop_block="\
while true; do
    sleep 60
done

"
else
    loop_block=""
fi

#---> DOS options processing
if [ "$dos" = "yes" ]; then
    dos_block="\
# DOS calculation
echo -e \"64\\n1\" | x kgen
x lapw1 -p -c -up
x lapw1 -p -c -dn
x lapw2 -p -c -qtl -up
x lapw2 -p -c -qtl -dn
dos_generate 55

"
else
    dos_block=""
fi


########################## Genaration of the job file ###################
if [ ! -d "job" ]; then
    mkdir job
fi

cat << EOF > $outfile
#!/bin/bash

#PBS -d $init_dir
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$walltime:00:00
#PBS -V
#PBS -o $init_dir/job/\${PBS_JOBID}.out
#PBS -e $init_dir/job/\${PBS_JOBID}.err

source $HOME/.bashrc
export SCRATCH=$init_dir/scratch
echo "=== scratch dir is \$SCRATCH"
if [ ! -d "\$SCRATCH" ]; then
    mkdir \$SCRATCH
fi
cd $init_dir

rm -f .machine*
rm -f .finished*
#rm -f job/\${PBS_JOBID}.out job/\${PBS_JOBID}.err

nodes_list=\$(cat \${PBS_NODEFILE} | sort | awk '{print \$1}')
uniq_nodes_list=\$(echo "\${nodes_list}" | sort | uniq)
uniq_nodes_num=\$(echo "\${uniq_nodes_list}" | wc -l)
kpar_block=""
for ((i=1; i<=\${uniq_nodes_num}; i++)); do
    unset kpar_node
    kpar_node=\$(echo "\${uniq_nodes_list}" | head -\$i | tail -1)
    kpar_nodes=\$(echo \$(echo "\${nodes_list}" | grep "\${kpar_node}"))
    if [ ! -z "\${kpar_block}" ]; then
        kpar_block="\
\${kpar_block}
1:\${kpar_nodes}"
    else
        kpar_block="\
1:\${kpar_nodes}"
    fi
done

machines_var="\
${lapw0_string}\
\${kpar_block}
granularity:1
extrafine:1"

echo "\${machines_var}" > .machines

nohup meminfo > /dev/null 2>&1 &

sleep 1

${init_string}\
${scf_string_block}\
${dos_block}\
${loop_block}

EOF

if [ -f "$outfile" ]; then
    chmod 755 $outfile
fi

#---> Report to a user about selected options
echo -e "
The job file $(basename $outfile) was generated with the following options:

Nodes/cores     : $nodes/$ppn
Walltime        : $walltime"

if [ ! -z "${lapw0_string}" ]; then
    echo -e "\
Parallel lapw0  : Yes"
else
    echo -e "\
Parallel lapw0  : No"
fi

if [ ! -z "${init_opts}" ]; then
    echo -e "\
Initialization  : Yes
Init parameters : $(echo "${init_string}" | grep . | head -1)"
else
    echo -e "\
Initialization  : No"
fi

if [ ! -z "${scf_string}" ]; then
    echo -e "\
SCF calculation : ${scf_string}"
else
    echo -e "\
SCF calculation : No"
fi


if [ "${loop}" = "yes" ]; then
    echo -e "\
Loop after a job: Yes"
else
    echo -e "\
Loop after a job: No"
fi

if [ "$dos" = "yes" ]; then
    echo -e "\
DOS calculation : Yes"
else
    echo -e "\
DOS calculation : No"
fi

if [ "${qsub}" = "yes" ]; then
    echo -e "\
Submit          : Yes\n"
    qsub $outfile
else
    echo -e "\
Submit          : No"
fi

echo


exit 0

